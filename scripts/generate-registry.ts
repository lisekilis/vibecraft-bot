import { readdirSync, writeFileSync } from 'node:fs';
import { basename, dirname, join, posix } from 'node:path';
import { fileURLToPath, pathToFileURL } from 'node:url';

const __dirname = dirname(fileURLToPath(import.meta.url));

const COMMAND_TYPES = ['activity', 'chatInput', 'message', 'user'] as const;
const COMMANDS_DIR = join(__dirname, '..', 'src', 'discord', 'commands');
const OUTPUT_FILE = join(COMMANDS_DIR, 'registry.ts');

interface CommandEntry {
	type: string;
	/** filename without extension (= Discord command name) */
	name: string;
	/** safe JS identifier for the import */
	alias: string;
	/** relative path from registry.ts */
	importPath: string;
}

function toSafeAlias(type: string, name: string): string {
	// Replace any non-alphanumeric characters with underscores
	return `${type}_${name.replace(/[^a-zA-Z0-9]/g, '_')}`;
}

async function discoverCommands(): Promise<CommandEntry[]> {
	const entries: CommandEntry[] = [];

	for (const type of COMMAND_TYPES) {
		const dir = join(COMMANDS_DIR, type);
		let files: string[];
		try {
			files = readdirSync(dir);
		} catch {
			// Directory doesn't exist yet — skip
			continue;
		}

		for (const file of files) {
			// Skip the factory index.ts
			if (file === 'index.ts') continue;
			// Only .ts files
			if (!file.endsWith('.ts')) continue;
			// Check if the file exports a valid command
			const commandModulePromise = import(pathToFileURL(join(dir, file)).href).catch((err) => {
				console.warn(`Warning: Failed to import command file ${file}. Skipping it in the registry. Error: ${err}`);
			});
			if (!commandModulePromise) continue;

			const commandModule = await commandModulePromise;
			if (!commandModule || typeof commandModule.default !== 'object' || !commandModule.default.execute) {
				console.warn(`Warning: Command file ${file} does not export a valid command object. Skipping it in the registry.`);
				continue;
			}

			const name = basename(file, '.ts');
			entries.push({
				type,
				name,
				alias: toSafeAlias(type, name),
				importPath: `./${posix.join(type, name)}`,
			});
		}
	}

	return entries;
}

function generateRegistry(entries: CommandEntry[]): string {
	const lines: string[] = [
		'// This file is auto-generated by scripts/generate-registry.ts',
		'// Do not edit manually. Run `pnpm generate:registry` to regenerate.',
		'',
		"import type { Command } from '../../types';",
		'',
	];

	// Static imports
	for (const entry of entries) {
		lines.push(`import ${entry.alias} from '${entry.importPath}';`);
	}

	lines.push('');

	// Build the registry type + object
	lines.push('type CommandType = ' + COMMAND_TYPES.map((t) => `'${t}'`).join(' | ') + ';');
	lines.push('');
	lines.push('export const registry: Record<CommandType, Record<string, Command>> = {');

	for (const type of COMMAND_TYPES) {
		const typeEntries = entries.filter((e) => e.type === type);
		lines.push(`\t${type}: {`);
		for (const entry of typeEntries) {
			// Key is the command name as Discord knows it (filename without extension)
			lines.push(`\t\t'${entry.name}': ${entry.alias},`);
		}
		lines.push('\t},');
	}

	lines.push('};');
	lines.push('');

	return lines.join('\n');
}

const entries = discoverCommands().then((entries) => {
	const content = generateRegistry(entries);
	writeFileSync(OUTPUT_FILE, content, 'utf-8');
	console.log(`Registry generated with ${entries.length} command(s) → ${OUTPUT_FILE}`);
});
